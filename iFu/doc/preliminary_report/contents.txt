ifu初赛设计报告

1. 项目概述
1.1 项目背景
    本项目是复旦大学在第八届龙芯杯全国大学生计算机系统能力培养大赛（NSCSCC 2024）团队赛的参赛作品
    基于loongArch32架构，我们在FPGA平台上面实现了一个乱序多发射CPU，可以通过发布包中全部的功能测试以及性能测试
1.2 开发语言
    本项目使用新型硬件语言——chisel来编写。
    Chisel是一种开源，在RTL级别描述数字电子电路的硬件描述语言，可以在FPGA实验平台进行方便地开发。
    Chisel将硬件构造原语添加到Scala编程语言中，为设计者提供了现代编程语言的能力，可以编写复杂的、可参数化的电路生成器，从而生成可综合的Verilog。这种生成器方法能够创建可重用的组件和库，例如Chisel标准库中的FIFO队列和仲裁器，从而提高设计中的抽象级别，同时保持精细的控制。
    此外，chisel的类，函数式编程，参数传递都更为灵活，可以大大提高编写复杂逻辑的开发效率以及可读性。

1.3 CPU架构
    iFuCore是一个乱序多发射CPU，实现前后端解耦，通过fetch Buffer来进行前后端之间指令的传递。
    1.3.1前端
    宽度为4，主要任务包括分支预测以及取指令
    由于令后端的uop携带完整的PC会使得后端数据流负担很大，因此我们将pc信息保留在前端的queue里面，后端如有需要（例如，jirl，branch类指令），
    会通过自己uop持有的idx  去取出pc使用，另外我们注意到branch类指令计算目标地址所需的imm和pc信息在前端取出inst时便可全部得到，因此前端
    增加一个预译码(predecode)阶段及时计算并纠正target_pc，于是后端只需要判断是否taken即可。

    1.3.2后端
    后端发射宽度为3，分为两个发射队列，包括计算和访存两部分，计算流水线有三个计算单元，可以执行csr，乘除法，跳转判断，以及普通运算指令
    特别地，我们通过chisel搭建核内性能计数器之后，发现很多测试点的访存指令占比很大(40%)，访存导致的阻塞对于乱序执行是很大的损失，因此我们尝试搭建
    高效率的，两条流水线的非阻塞dcache以及包括访存内部转发的Lsu，使得CPU处理访存的效率大大加强，这会导致Lsu板上面积很大，对频率提升有影响，但是我们
    发现其对ipc带来的提升收益更大，因此选择这种结构。

    1.3.3缓存设计
    icache：
    我们经过前后端的指令数据分析，发现后端的处理速度要大于前端的供指速度，我们前端的供值能力成为瓶颈，因此我们需要保障icache为8路，以匹配分支预测和后端的需求
    icache采用VIPT的匹配策略，LRU的替换策略 每路为4KB
    
    dcache
    dcache采用PIPT的匹配模式（在地址计算的时候会同时用一周期进行地址翻译），将地址和dcache执行进行解耦，以减轻频率负担，dcache访存分三级执行，拥有两条流水线，同周期处理至多一条store指令，最多两条load指令
    dcache为4路，64Sets，每行16字（AXI协议支持的单次最大burst长度），每路为4KB


    1.4 分支预测器设计
    分支预测使用三阶段分支预测，s1通过一个ubtb进行next Line Predict
    s2进行btb的地址判断，以及bim的判断
    s3输出通过13位局部历史预测器的跳转结果，由于局部历史学习时间较长，其只有具备一定置信度，才可以推翻s2bim给出的跳转结果。
    同时，s3还会通过预译码严格确定分支预测跳转的目标地址，由于预译码结果一定正确，因此如有不同，可以推翻前面btb给出的target。
